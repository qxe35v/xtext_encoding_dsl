/*
 * generated by Xtext 2.12.0
 */
package org.xtext.example.generator

import org.eclipse.emf.ecore.resource.Resource
import org.eclipse.xtext.generator.AbstractGenerator
import org.eclipse.xtext.generator.IFileSystemAccess2
import org.eclipse.xtext.generator.IGeneratorContext
import org.xtext.example.encodingLang.SourceMapping
import org.xtext.example.encodingLang.Conversion
import org.xtext.example.generator.HexToDec
import org.eclipse.xtend.lib.annotations.Accessors

/**
 * Generates code from your model files on save.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#code-generation
 */
class EncodingLangGenerator extends AbstractGenerator {

	override void doGenerate(Resource resource, IFileSystemAccess2 fsa, IGeneratorContext context) {
//		fsa.generateFile('greetings.txt', 'People to greet: ' + 
//			resource.allContents
//				.filter(Greeting)
//				.map[name]
//				.join(', '))
		//TODO (xtend-gen, bin) <- .gitignore
		//TODO vegen if-ek, doksi eleje, modell tesztelés, c-s fordítás
		fsa.generateFile(resource.calcFileName+".txt", resource.generate )
	}
	
	def String calcFileName(Resource r){
		var String s = r.toString
		var int i=s.length-1
		while( s.charAt(i).equals('/'.charAt(0))==false ){
			i--;
			System.out.println(s.charAt(i));
		}
		return s.substring(i,s.length-6)+"_gen";
	}
	
	def generate(Resource r) '''
	//Generated by HIM
	#include <assert.h>
	#include <hashtable.h>
	
	«r.generateAliases»
	
	«r.generateUnitLengths»
	
	«r.generateMappings»
	
	'''
	def generateAliases(Resource r)'''
		hashtable* aliases_hashbtable(){
			hashtable* aliases = hashtable_init(256, sizeof(char**), sizeof(char**));
			
			«FOR s: r.allContents.toIterable.filter(SourceMapping)»
			//aliases for «s.name»
			const char* encoding_«s.name» = "«s.name»"; 
			hashtable_put(aliases,&encoding_«s.name»,&encoding_«s.name»);
			
			«FOR a: s.aliases»
			//put to «s.name» alias «a.name»
			const char* alias_«a.name»_for_«s.name» = "«a.name»";
			hashtable_put(aliases,&encoding_«s.name»,&alias_«a.name»_for_«s.name»);
			
			«ENDFOR»
			
			«ENDFOR»
			return aliases;
			}
	'''
	
	def generateUnitLengths(Resource r)'''
		hashtable* unit_lenghts(){
			hashtable* unit_lengths = hashtable_init(128, sizeof(char**), sizeof(uint8_t*));
			
			«FOR s: r.allContents.toIterable.filter(SourceMapping)»
			«IF !s.conversions.isEmpty && !s.conversions.get(0).mappings.isEmpty»
			//unit legnths for «s.name»
			const char* encoding_«s.name» = "«s.name»";
			uint8_t length_«s.name» = «(s.conversions.get(0).mappings.get(0).from.length-2)/2»;
			hashtable_put(unit_lengths, &encoding_«s.name», &length_«s.name»);
			
			«FOR c:s.conversions»
			//unit length for «c.name»
			const char* encoding_«s.name»_to_«c.name» = "«c.name»";
			uint8_t length_«s.name»_to_«c.name» = «(c.mappings.get(0).to.length-2)/2»;
			hashtable_put(unit_lengths, &encodding_«s.name»_to_«c.name», &length_«s.name»_to_«c.name»);
			
			«ENDFOR»
			
			«ENDIF»
			«ENDFOR»
			return unit_lengths;
			}
	'''
	
	def generateMappings(Resource r)'''
		hashtable* mappings(){
			// hashtable for everything
			hahstable* mappings = hashtable_init(128, sizeof(char**), sizeof(hashtable* );1
			
			«FOR s:r.allContents.toIterable.filter(SourceMapping)»
			// hashtable for «s.name»
			const char* encoding_«s.name» = "«s.name»";
			hashtable mappings_from_«s.name» = hahstable_init(128, sizeof(char**), sizeof(hashtable*));
			hashtable_put(mappings, &encoding_«s.name», mappings_from_«s.name»);
			
			«FOR c:s.conversions»
			«IF !c.mappings.isEmpty»
			// hash for «s.name»->«c.name»
			const char* encoding_«s.name»_to_«c.name» = "«c.name»";
			hashtable mappings_from_«s.name»_to_«c.name» = hashtable_init(
				«IF c.mappings.get(0).from.length == 4»
				512,
				sizeof(uint8_t*),
				«ELSE»
					«IF c.mappings.get(0).from.length == 6»
					31072,
					sizeof(uint16_t*),
					«ELSE»
						8589934592,
						sizeof(uint32_t*),
					«ENDIF»
				«ENDIF»
				«IF c.mappings.get(0).to.length == 4»
				sizeof(uint8_t*));
				«ELSE»
					«IF c.mappings.get(0).to.length == 6»
					sizeof(uint16_t*));
					«ELSE»
						sizeof(uint32_t*));
					«ENDIF»
				«ENDIF»
			hashtable_put(mappings_from_«s.name», &encoding_«s.name»_to_«c.name», mappings_from_«s.name»_to_«c.name»);
			
			//filling in «s.name»->«c.name»
			«IF c.mappings.get(0).from.length == 4»
					uint8_t from_value_«s.name»_to_«c.name»;
					«ELSE»
						«IF c.mappings.get(0).from.length == 6»
						uint16_t from_value_«s.name»_to_«c.name»;
						«ELSE»
							uint32_t from_value_«s.name»_to_«c.name»;
						«ENDIF»
					«ENDIF»
			«FOR m:c.mappings»
			from_value_«s.name»_to_«c.name» = «HexToDec.hex2decimal(m.from)»;
			to_value_«s.name»_to_«c.name» = «HexToDec.hex2decimal(m.to)»;
			hashtable_put(
				mappings_from_«s.name»_to_«c.name»,
				&from_value_«s.name»_to_«c.name»,
				&to_value_«s.name»_to_«c.name»);
				
			«ENDFOR»
			
			«ENDIF»
			«ENDFOR»
			
			«ENDFOR»
		}
	'''
}
